''' 건물사이에 빗물이 잠길 수 있는 양을 계산하는 코드 '''
def trapping_rain(buildings):
    sum = 0
    for i in range(1, len(buildings)-1):
        l_max = max(buildings[:i])
            # 현재 index 기준 왼쪽에서 가장 큰 건물의 높이 저장
        r_max = max(buildings[i:])
            # 현재 index 기준 오른쪽에서 가장 큰 건물의 높이 저장

        sum += max(0, min(l_max, r_max) - buildings[i])
            # 빗물의 양은 오른쪽과 왼쪽 건물 중 낮은 건물을 기준으로 하며 현 index에 건물이 있다면 그만큼의 값을 빼주어야 한다.
    return sum

# 테스트
print(trapping_rain([3, 0, 0, 2, 0, 4]))
print(trapping_rain([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))

''' ------ 동작 설명 ------
1. 건물의 높이를 요소로 표현한 index를 파라미터로 받는다.
2. 현재 index [i]를 기준으로 왼쪽[:i]과 오른쪽[i:]의 각각 가장 큰 건물 높이를 찾는다.
3. 두개의 건물 중 낮은 건물만큼 빗물이 담길 수 있으므로, 낮은 건물의 높이를 찾는다.
4. 현 index에 건물이 있을 경우 그만큼 빗물의 자리를 차지하므로, 낮은 건물의 높이에서 현재 높이를 뺀다.

 ------ 어려웠던 점 ------
 count를 이용하여 건물이 없는 index의 수를 세고, 우측 및 좌측 건물 높이와 곱하는
 전형적인 넓이를 구하는 공식을 사용하려고 했다. 나름대로 무작위 대입을 활용했으나
 코드 구현이 굉장히 복잡해졌고, 결국 그 방법은 실패했다. 
 
 무엇보다 현재 index에 담긴 물의 양만 구한 뒤 그것을 모두 더해줬으면 간단히 해결했을 문제를
 한번에 전체 넓이를 구하려고 하니 이런 불규칙적인 문제에서는 제대로 해결되지 않았다.

 ------ 시간 복잡도 ------
 O(n^2)
 for문은 하나만 사용했으므로 O(n)이지만, 반복문 내에서 max 메소드를 이용했다.
 최악의 경우 max 값을 찾기 위해서는 리스트 전체 범위를 탐색해야하는데(O(n))
 max 메소드가 2개 이므로 O(n) + O(n) = O(2n) = O(n)이다.

 결국 for문의 시간복잡도 O(n) * max의 시간복잡도 O(n) = O(n^2)가 되는 것이다.
 '''
