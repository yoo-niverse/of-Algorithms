''' merge 함수를 이용하여 분할 정복을 적용 후 합병정렬을 수행하는 코드 '''
from Merge import *

# 합병 정렬
def merge_sort(my_list):

    if len(my_list) <= 1:
        return my_list

    mid = len(my_list) // 2

    part1 = merge_sort(my_list[:mid])
    part2 = merge_sort(my_list[mid:])

    return merge(part1, part2)

# 테스트
print(merge_sort([1, 3, 5, 7, 9, 11, 13, 11]))
print(merge_sort([28, 13, 9, 30, 1, 48, 5, 7, 15]))
print(merge_sort([2, 5, 6, 7, 1, 2, 4, 7, 10, 11, 4, 15, 13, 1, 6, 4]))

'''
 ------ 동작 설명 ------
 1. 합병 정렬을 수행할 list를 파라미터로 받는다.
 2. list의 길이가 1보다 작거나 같을 경우에는 정렬이 불필요하므로 그대로 return한다.
 3. 그 외에는 // 연산을 이용하여 중간 index를 계산하고, 그를 토대로 list를 2개 영역으로 분할한다.
 4. 분할한 리스트를 각각 재귀호출을 통해 합병정렬을 수행하고, 최종적으로 merge 함수를 이용하여 두 list를 합쳐 하나의 list로 반환한다. 
 
 ------ 어려웠던 점 ------
 예제를 풀면서 지금까지 어려웠던 문제는 많았지만, 대부분 힌트만 보고 풀어낼 수 있었다.
 그런데 합병정렬은 아무리 수행해도 정상적인 결과가 안나와서 한참 고민하다
 결국 해설을 봤는데, 내가 작성한 코드와 다른 내용이 딱히 없었다. 
 
 대체 왜 작동에 오류가 있는건지 모르겠어서 일단 질문을 남겨놨다..
 
  + 질문을 올리고나서 이것저것 시도해보다 알게 됐는데, merge_sort 함수는
  정상적으로 동작했다. 모범답안에서 merge 함수를 내 코드로 바꾸니 작동이 안됐다.
  
  확인결과 처음 작성했던 merge 코드에서 2개 list의 각 요소를 변경하는 while문 내부에
  요소를 sorted_list에 추가하기 직전 해당 요소가 이미 list에 존재하는지 확인하는 코드를 넣어두었다.
  그 코드 때문에 정상작동이 되지 않았던 것으로 예상되는데,
  내가 생각을 잘못했던게 index마다 같은 값이 있을 수도 있으니 그걸 그대로 정렬하면 됐지만
  나는 정렬하면서 중복값을 제거해야한다고 생각해서 그렇게 한 것이었다..
  
  결국 잘못된 판단으로, 처음에 짠 코드가 발목을 잡아 한참 고민했다. 너무 슬프다.
  '''
